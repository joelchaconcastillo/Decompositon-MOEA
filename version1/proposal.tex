This section is devoted to describe our proposal the \textit{Variable Space Diversity \MOEA{} based in Decomposition} (\VSDMOEAD{}), which is categorized as a decomposition-based \MOEA{}.
%
In particular, the motivation behind \VSDMOEAD{} is the incorporation of techniques to improve further more the performance of decomposition-based algorithms in long-term executions.
%
Although that \VSDMOEAD{} is inspired in the \MOEAD{}, its design is quite similar to some older \MOEAS{}.
%
The main reason of this is that \VSDMOEAD{} leaves out several representative components of the \MOEAD{}.
%
In fact, it follows similar ideas found in the \MOGA{} and \CMOGA{}~\cite{murata2002cellular}.
%
In the \CMOGA{} each individual resides in a different cell, such cells belong to a spatially structure space formed in a $m$-dimensional weight space.
%
Therefore, each cell has its own weight vector.
%
Equivally to \MOEAD{} and \CMOGA{}, \VSDMOEAD{} incorporates sub-problems where each one manages a different weight vector.
%
Thus, each sub-problem is associated to each individual from the population.
%
However, \VSDMOEAD{} drop out the neighbourhoods definition, being perhaps the most representative characteristic of \CMOGA{} and \MOEAD{}.
%
Similarly than \MOGA{}, in \VSDMOEAD{} the mating and the replacement restrictions are applyied among the whole population.
%
Contrary to \MOGA{} where the weight vectors are randomly generated in each generation, in \VSDMOEAD{} the application of the weight vectors remains fixed along the whole execution.
%

Our proposal decomposes the \MOP{} in several single-objective problems.
%
Notwithstanding that any decomposition approach can be employed to decompose the \MOP{}, in this work is incorporated the Tchebycheff approach.
%
Let $\lambda_1, ..., \lambda_N$ a set of even spread weight vectors and $z^*$ be the reference point.
%
The decomposition into $N$ scalar optimization sub-problems by using the Tchebycheff approach and the objective function of the $j$-th sub-problem is indicated in the Eq. (\ref{eqn:approach}).
%

\begin{equation}\label{eqn:approach}
\displaystyle{
g^{te}(x| \lambda_j, z^*) = \max_{ 1 \leq i \leq m} \{ \lambda_{j,i} | f_i(x) - z_i^*|\}
}
\end{equation}


The main contribution of the \VSDMOEAD{} is the incorporation of a survivor selection scheme.
%
This selection aims to explorate the decision variable space through differents stages.
%
Such goal is achieved incorporating the stopping criterion and elapsed generations.
%
In this way, the search is gradually driven from exploration to exploitation.
%
Mainly, the diversity is explicitly promoted until a half of total generations. 
%
In the remaining generations the \VSDMOEAD{} has a similar behavior than the habitual \MOEAS{}.
%

The main procedure of the \VSDMOEAD{} is shown in the Algorithm~\ref{alg:vsd-moead}.
%
This pseudo-code integrates two populations; the parent population ($P$) and offspring population ($Q$).
%
The role of the former is to explicitly maintain diverse individuals in several stages.
%
Beginning, in line~\ref{alg_1:1} is initialized the first parent population $P^0$, i.e. are randomly generated $N$ individuals inside the decision variable space.
%
After that, a set of spread weight vectors are defined in line~\ref{alg_1:2}.
%
Then, in line~\ref{alg_1:3} the individuals of the initial population $P^0$ are evaluated.
%
Those evaluations are employed to built a reference vector $z^*$, which is composed by the best attained objective values (line \ref{alg_1:4}).
%
Then, iteratively (lines \ref{alg_1:5} - \ref{alg_1:13}) each $t$-th generation proceeds as follows.
%
First, the offspring population $Q^t$ is generated through the standard \DE{} strategy, which involves the mating selection and the variation operators.
%
Then, in the survivor selection stage (line \ref{alg_1:11}), are selected the survivors of the next generation $P^{t+1}$.
%
Particularly, are merged $P^t$ and $Q^t$ picking up $N$ individuals.
%
At this point is clear that the main framework of the \VSDMOEAD{} is quite common.
%
Therefore, its main contribution appears in the replacement phase which takes its part inside the survivor selection and is explained in the following section.
%

\begin{algorithm}[!t]
\algsetup{linenosize=\tiny}
        \caption{Main procedure of \VSDMOEAD{}}
        \begin{small}
\begin{algorithmic}[1]
        \STATE \textbf{Initialization}: Generate an initial population $P^0$ with $N$ individuals \label{alg_1:1}
        \STATE Let $\lambda = \{\lambda_1, ..., \lambda_N \}$ be a set of even spread weight vectors \label{alg_1:2}
        \STATE \textbf{Evaluation}: Evaluate each individual in $P^0$ and assemble the reference vector $z^*$ with the best objective values \label{alg_1:3}
        \STATE Assign $t=0$ \label{alg_1:4}
        \WHILE{ (not stopping criterion)  } \label{alg_1:5}
           \FOR{ each individual $i \in P^t$} \label{alg_1:6}
               \STATE \textbf{Mating selection}: Select randomly three indexes ($r_1 \neq r_2 \neq r_3 \neq i$) from the entire population. \label{alg_1:7}
               \STATE \textbf{Variation}: Generate a solution $y$ from $P^t_{r_1}$, $P^t_{r_2}$ and $P^t_{r_3}$ by \DE{} operator. Then perform a polynomial mutation on $y$ with probability $p_m$ to produce a new solution $Q^t_{i}$. \label{alg_1:8}
               \STATE \textbf{Evaluation}: Evaluate the new individual $Q^t_{i}$ and update the reference vector $z^*$ with the best objective values. \label{alg_1:9}
           \ENDFOR \label{alg_1:10}
           \STATE \textbf{Survivor selection}: Generate $P^{t+1}$ by applying the replacement scheme described in  Algorithm \ref{alg:replacement}, using $P^t$, $Q^t$, $\lambda$ and $z^*$ as input \label{alg_1:11}
           \STATE $t=t+1$ \label{alg_1:12}
        \ENDWHILE \label{alg_1:13}
        \end{algorithmic}
        \end{small}
\label{alg:vsd-moead}
\end{algorithm}


%
\subsection{Novel Replacement Phase Incorporated to \VSDMOEAD{} }


The purpose of the replacement phase is the selection of individuals in the current generation that will survive in the next generation.
%
The survivor selection described in this work incorporates the same principle that the one applied in single-objective optimization~\cite{castillo2019differential}.
%
The survivor selection scheme is explained as follows.
%
First, the parent set and offspring set are merged in a multi-set, better known as the candidate set.
%
Then, iteratively an individual from the candidate set that better fulfills some requirements is moved to the survivor set.
%
In particular, the next two requirements are taken into account.
%
The contribution to the diversity in the decision variable space and the scalarizing function value in the objective space.
%
In spite that the former can be computed in several ways, in this work we define the Distance to Closest Survivor (\DCS{}).
%
This definition quantifies the contribution to the diversity of an individual if it were introduced into a reference set.
%
A formal definition is $\displaystyle{\min_{p \in P}\ Distance(x, p)}$, where $P$ is the multi-set of the already picked survivors and $x$ is the individual whose contribution is being computed.
%
Without loss of generality, we integrate the normalized Euclidean distance, which is specified in the Eq. (\ref{eqn:distance}).
%
This equation measures the distance between two individuals $A$ and $B$.
%
\begin{equation}\label{eqn:distance}
Distance(A, B) =   \left ( \frac{1}{n}  \sum_{i=1}^n \left ( \frac{A_i - B_i}{x_i^{(U)} - x_i^{(L)}} \right )^2  \right)^{1/2}
\end{equation}

This survivor selection scheme is governed by a gradual transition between exploration to exploitation.
%
Such transition can be achieved requiring a \DCS{} value among the population in each generation.
%
Accordingly, the selection of survivors with larger \DCS{} values contribute more significantly to the exploration.
%
Otherwise, shorter \DCS{} values might induce exploitation.
%
Therefore, in this heuristic to promote high levels of exploration, the candidates with a \DCS{} value below a threshold are penalized.
%
Then, each individal from the non-penalized set is associated with an available weight vector whose scalarizing function value is the best.
%
Finally, the individual with the best scalarizing function value among the non-penalized set is moved to the survivor set disabling its associated weight vector.
%
Note that it might occurs that all individuals are penalized, in such case the individual with the largest \DCS{} is selected to survive.

%
The pseudo-code of the replacement phase is shown in the Algorithm~\ref{alg:replacement}.
%
First, at the $t$-th generation the parent set $P^t$ and the offspring set $Q^t$ are merged in the candidate multi-set $R^t$ (line \ref{alg_2:1}).
%
At each iteration, the candidate set $R^t$ represents the individuals that are non-penalized and might be selected to survive.
%
In lines \ref{alg_2:2} - \ref{alg_2:4}, the survivor set $P^{t+1}$, the penalized set and a weight vector set $\lambda^{t+1}$ are initialized to the empty set.
%
Then, the threshold value $D^t$ that is used to penalize individuals that are too close is calculated in line \ref{alg_2:5}.
%
Note that the required diversity that is promoted through this threshold is decreased linearly.
%
In addition, the diversity that is initially promoted is indicated by $D_I$, which is the initial threshold value, $G_{Elapsed}$ is the number of generations that have evolved, and $G_{End}$ is the stopping criterion.
%
Then, iteratively the selection is performed until the survivor set contains $N$ individuals.
%
Particularly, each survivor is picked up as follows (lines \ref{alg_2:6} - \ref{alg_2:16}).
%
First, the most close individuals from the candidate set $R^t$ are moved to the penalized set (lines \ref{alg_2:7} - \ref{alg_2:8}).
%
Among the non-penalized set $R^t$, each individual is paired with each available weight vector $\lambda^t$, selecting the individual with the best scalarizing function value (lines \ref{alg_2:13} - \ref{alg_2:14}).
%
Finally, the associated weight vector is temporally disabled, i.e. it is moved to the set of the next generation $\lambda^{t+1}$ (line \ref{alg_2:15}).
%
In the case in which all the individuals are penalized, then is selected the one with the best contribution to the diversity and is moved to the survivor set $P^{t+1}$.
%
The linear decrease of the required diversity is calculated such that after $50\%$ of the total number of generations, the $D^t$ value is below 0, meaning that no penalties are applied.
%
This means that in the first $50\%$ of the total generations, more exploration is induced and in the remaining generations \VSDMOEAD{} behaves similarly than in the habitual \MOEAS{}.
%
At this point it can be noted that the proposed replacement phase requires the level of diversity that is promoted initially $D_I$.
%
Nevertheless, in the next section is shown that this parameter can be set in a wide range of values without affecting the algorithmic performance.


\begin{algorithm}[t]
\algsetup{linenosize=\tiny}
        \caption{Replacement Phase of \VSDMOEAD{}}
\begin{small}
\begin{algorithmic}[1]
\STATE Input: $P^t$ (Parent of current generation), $Q^t$ (Offspring of current generation), $\lambda^t$ (a set of weight vectors) and $z^*$ (Reference vector)
        \STATE Output: $P^{t+1}$
        \STATE $R^t = P^t \cup Q^t$\label{alg_2:1} 
        \STATE $P^{t+1} = \emptyset$ \label{alg_2:2}
        \STATE $Penalized = \emptyset$ \label{alg_2:3}
	\STATE $\lambda^{t+1} = \emptyset$ \label{alg_2:4}
        \STATE $D^t = D_I - D_I * \frac{G_{Elapsed}}{0.5*G_{End}}$ \label{alg_2:5} 
        \WHILE{ $|P^{t+1}| \leq  N$} \label{alg_2:6}
            \STATE Compute $DCS$ in $R^t$ using $P^{t+1}$ as reference set \label{alg_2:7}
            \STATE Move the individuals in $R^t$ with $DCS < D^t$ to $Penalized$ \label{alg_2:8}
%	   \STATE Compute the diversity-contribution of each candidate $i \in R^t$ to the survivor set $P^{t+1}$\label{alg:7}
%	   \STATE Move the crowdest individuals from $R^t$ to $Penalized$; Those individuals whose diversity-contribution is less than the threshold $D^t$\label{alg:8}
                \IF{$R^t$ is empty} \label{alg_2:9}
                    \STATE Compute $DCS$ of each individual in $Penalized$ set employing $P^{t+1}$ as reference set \label{alg_2:10}
                    \STATE Move the individual in $Penalized$ with the largest $DCS$ to $R^t$ \label{alg_2:11}
%		    \STATE Compute the diversity-contribution of each individual in $Penalized$ to the survivor set $P^{t+1}$\label{alg:10}
%                    \STATE Move the most suitable individual from $Penalized$ to the survivor set $R^t$; the one with the highest diversity-contribution to $R^t$ \label{alg:11}
                \ENDIF \label{alg_2:12}
            \STATE Identify the non-penalized individual $R_i^t$ and the weight vector $\lambda_i^t$ with the best scalarizing function value according to $g^{te}(R_i^t | \lambda_j^t, z^*)$ \label{alg_2:13}
%	    \STATE $\displaystyle{ R_i^t, \lambda_i = \max_{k \in |R^t|, l \in |\Lambda|} g(R_k^t | \lambda_l, \mathbf{z})}$ 
	    \STATE Move the non-penalized individual $R_i^t$ to $P^{t+1}$ \label{alg_2:14}
            \STATE Move the associated weight vector $\lambda^t_j$ to $\lambda^{t+1}$ \label{alg_2:15}
        \ENDWHILE \label{alg_2:16}
        \RETURN $P^{t+1}$ \label{alg_2:17}
        \end{algorithmic}
\end{small}
\label{alg:replacement}
\end{algorithm}

